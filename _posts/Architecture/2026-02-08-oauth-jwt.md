---
title: "[Architecture] 인증/인가 - OAuth 2.0, JWT, Session 완벽 이해"
categories:
  - Architecture
tags:
  - [OAuth, JWT, Authentication, Authorization, Security]
---

# Introduction

---

**인증(Authentication)**은 "누구인가?"를 확인하고, **인가(Authorization)**는 "무엇을 할 수 있는가?"를 결정합니다. 웹 서비스에서 가장 흔한 방식은 **세션 기반**과 **토큰 기반(JWT)** 인증입니다. **OAuth 2.0**은 제3자 애플리케이션에 안전하게 권한을 위임하는 표준 프로토콜입니다.

이 글은 각 방식의 동작 원리와 선택 기준을 정리합니다.

# 1. 인증 vs 인가

---

```text
인증 (Authentication):
  - 신원 확인
  - "당신은 누구입니까?"
  - 예: 로그인

인가 (Authorization):
  - 권한 확인
  - "당신은 이 작업을 할 수 있습니까?"
  - 예: 관리자만 삭제 가능
```

## 흐름

```text
1. 인증: 사용자가 ID/비밀번호로 로그인
2. 신원 확인: 서버가 사용자 확인
3. 자격증명 발급: 세션 ID 또는 토큰 발급
4. 요청: 클라이언트가 자격증명과 함께 요청
5. 인가: 서버가 권한 확인 후 처리
```

# 2. 세션 기반 인증

---

## 동작 방식

```text
┌─────────┐                          ┌─────────┐
│ Client  │                          │ Server  │
└────┬────┘                          └────┬────┘
     │                                    │
     │ 1. POST /login (id, password)      │
     │ ─────────────────────────────────▶ │
     │                                    │ 2. 사용자 확인
     │                                    │ 3. 세션 생성 (메모리/Redis)
     │ 4. Set-Cookie: JSESSIONID=abc123   │
     │ ◀───────────────────────────────── │
     │                                    │
     │ 5. GET /api/users                  │
     │    Cookie: JSESSIONID=abc123       │
     │ ─────────────────────────────────▶ │
     │                                    │ 6. 세션 조회 → 사용자 확인
     │ 7. 응답                            │
     │ ◀───────────────────────────────── │
```

## 특징

```text
장점:
- 서버에서 세션 관리 → 즉시 무효화 가능
- 구현 단순 (Spring Security 기본)
- 민감 정보 서버에만 저장

단점:
- 서버에 상태 저장 (Stateful)
- 서버 확장 시 세션 공유 필요 (Redis)
- 모바일/SPA에서 쿠키 관리 복잡
```

## Spring Security 구현

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/login", "/signup").permitAll()
                .requestMatchers("/admin/**").hasRole("ADMIN")
                .anyRequest().authenticated()
            )
            .formLogin(form -> form
                .loginPage("/login")
                .defaultSuccessUrl("/home")
            )
            .sessionManagement(session -> session
                .maximumSessions(1)  // 동시 세션 1개
                .maxSessionsPreventsLogin(true)
            );
        return http.build();
    }
}
```

## 세션 저장소 (Redis)

```yaml
spring:
  session:
    store-type: redis
  redis:
    host: localhost
    port: 6379
```

```java
@EnableRedisHttpSession(maxInactiveIntervalInSeconds = 3600)
public class SessionConfig {
}
```

# 3. JWT (JSON Web Token)

---

## 구조

```text
Header.Payload.Signature

예시:
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.
eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkhvbmciLCJpYXQiOjE1MTYyMzkwMjJ9.
SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c

Header (Base64): {"alg": "HS256", "typ": "JWT"}
Payload (Base64): {"sub": "123", "name": "Hong", "iat": 1516239022, "exp": 1516242622}
Signature: HMACSHA256(base64(header) + "." + base64(payload), secret)
```

## 동작 방식

```text
┌─────────┐                          ┌─────────┐
│ Client  │                          │ Server  │
└────┬────┘                          └────┬────┘
     │                                    │
     │ 1. POST /login (id, password)      │
     │ ─────────────────────────────────▶ │
     │                                    │ 2. 사용자 확인
     │                                    │ 3. JWT 생성 (서명)
     │ 4. {"accessToken": "eyJ...", ...}  │
     │ ◀───────────────────────────────── │
     │                                    │
     │ 5. GET /api/users                  │
     │    Authorization: Bearer eyJ...    │
     │ ─────────────────────────────────▶ │
     │                                    │ 6. JWT 서명 검증
     │                                    │    Payload에서 사용자 정보 추출
     │ 7. 응답                            │
     │ ◀───────────────────────────────── │
```

## 특징

```text
장점:
- 서버에 상태 저장 안 함 (Stateless)
- 서버 확장 용이 (세션 공유 불필요)
- 모바일, SPA에 적합
- 클레임에 정보 포함 가능

단점:
- 토큰 탈취 시 만료까지 유효
- 즉시 무효화 어려움 (블랙리스트 필요)
- 토큰 크기가 세션 ID보다 큼
- Payload는 Base64 인코딩 (암호화 아님)
```

## 구현 예시

```java
// JWT 생성
public String createToken(User user) {
    Date now = new Date();
    Date expiry = new Date(now.getTime() + 3600000);  // 1시간

    return Jwts.builder()
        .setSubject(user.getId().toString())
        .claim("email", user.getEmail())
        .claim("roles", user.getRoles())
        .setIssuedAt(now)
        .setExpiration(expiry)
        .signWith(SignatureAlgorithm.HS256, secretKey)
        .compact();
}

// JWT 검증
public Claims validateToken(String token) {
    return Jwts.parser()
        .setSigningKey(secretKey)
        .parseClaimsJws(token)
        .getBody();
}
```

## Access Token + Refresh Token

```text
Access Token:
  - 짧은 만료 (15분 ~ 1시간)
  - API 요청에 사용
  - 탈취 시 피해 최소화

Refresh Token:
  - 긴 만료 (7일 ~ 30일)
  - Access Token 재발급에만 사용
  - 안전하게 저장 (HttpOnly Cookie, 서버 DB)
```

```java
// 토큰 재발급
@PostMapping("/refresh")
public TokenResponse refresh(@CookieValue("refreshToken") String refreshToken) {
    // 1. Refresh Token 검증
    if (!tokenService.validateRefreshToken(refreshToken)) {
        throw new UnauthorizedException("Invalid refresh token");
    }

    // 2. 새 Access Token 발급
    String userId = tokenService.getUserIdFromRefreshToken(refreshToken);
    String newAccessToken = tokenService.createAccessToken(userId);

    return new TokenResponse(newAccessToken);
}
```

# 4. OAuth 2.0

---

## 개념

제3자 애플리케이션에 **사용자 대신** 리소스 접근 권한을 부여하는 프로토콜입니다.

```text
예시:
- "GitHub로 로그인" → 내 앱이 GitHub API에 접근
- "Google 캘린더 연동" → 내 앱이 사용자의 캘린더 접근
- 사용자 비밀번호를 내 앱에 알려주지 않고 권한 부여
```

## 역할

| 역할 | 설명 | 예시 |
|------|------|------|
| **Resource Owner** | 리소스 소유자 (사용자) | GitHub 사용자 |
| **Client** | 권한을 요청하는 앱 | 내 웹 애플리케이션 |
| **Authorization Server** | 인증/권한 부여 | GitHub OAuth 서버 |
| **Resource Server** | 보호된 리소스 | GitHub API |

## Authorization Code Grant

가장 안전하고 일반적인 방식입니다.

```text
┌─────────┐          ┌─────────┐          ┌─────────────────┐
│ 사용자   │          │ My App  │          │ GitHub          │
└────┬────┘          └────┬────┘          └────────┬────────┘
     │                    │                        │
     │ 1. "GitHub로 로그인" 클릭                    │
     │ ─────────────────▶ │                        │
     │                    │                        │
     │ 2. GitHub 로그인 페이지로 리다이렉트          │
     │ ◀─────────────────────────────────────────▶ │
     │                    │                        │
     │ 3. 사용자가 GitHub에서 권한 승인              │
     │ ─────────────────────────────────────────▶ │
     │                    │                        │
     │ 4. Authorization Code와 함께 콜백           │
     │ ◀───────────────── │                        │
     │                    │                        │
     │                    │ 5. Code로 Access Token 요청
     │                    │ ─────────────────────▶ │
     │                    │                        │
     │                    │ 6. Access Token 발급   │
     │                    │ ◀───────────────────── │
     │                    │                        │
     │                    │ 7. GitHub API 호출 (Token)
     │                    │ ─────────────────────▶ │
     │                    │                        │
     │                    │ 8. 사용자 정보 응답     │
     │                    │ ◀───────────────────── │
     │                    │                        │
     │ 9. 로그인 완료      │                        │
     │ ◀───────────────── │                        │
```

## 구현 (Spring Security OAuth2)

```yaml
spring:
  security:
    oauth2:
      client:
        registration:
          github:
            client-id: ${GITHUB_CLIENT_ID}
            client-secret: ${GITHUB_CLIENT_SECRET}
            scope: read:user, user:email
          google:
            client-id: ${GOOGLE_CLIENT_ID}
            client-secret: ${GOOGLE_CLIENT_SECRET}
            scope: openid, profile, email
```

```java
@Configuration
@EnableWebSecurity
public class OAuth2SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/", "/login/**").permitAll()
                .anyRequest().authenticated()
            )
            .oauth2Login(oauth2 -> oauth2
                .userInfoEndpoint(userInfo -> userInfo
                    .userService(customOAuth2UserService)
                )
                .successHandler(oAuth2SuccessHandler)
            );
        return http.build();
    }
}

@Service
@RequiredArgsConstructor
public class CustomOAuth2UserService extends DefaultOAuth2UserService {

    private final UserRepository userRepository;

    @Override
    public OAuth2User loadUser(OAuth2UserRequest request) {
        OAuth2User oAuth2User = super.loadUser(request);

        String provider = request.getClientRegistration().getRegistrationId();
        String providerId = oAuth2User.getAttribute("id").toString();
        String email = oAuth2User.getAttribute("email");
        String name = oAuth2User.getAttribute("name");

        // 기존 사용자 조회 또는 신규 생성
        User user = userRepository.findByProviderAndProviderId(provider, providerId)
            .orElseGet(() -> userRepository.save(
                User.builder()
                    .provider(provider)
                    .providerId(providerId)
                    .email(email)
                    .name(name)
                    .role(Role.USER)
                    .build()
            ));

        return new CustomOAuth2User(user, oAuth2User.getAttributes());
    }
}
```

## OAuth 2.0 Grant Types

| 타입 | 사용 상황 |
|------|----------|
| **Authorization Code** | 서버 사이드 앱 (가장 안전) |
| **Authorization Code + PKCE** | SPA, 모바일 앱 |
| **Client Credentials** | 서버 간 통신 (사용자 없음) |
| **Refresh Token** | Access Token 재발급 |

# 5. 소셜 로그인 + JWT

---

OAuth로 소셜 로그인 후 JWT를 발급하는 패턴입니다.

```text
1. 사용자가 "Google로 로그인" 클릭
2. Google OAuth 인증 (Authorization Code)
3. 내 서버에서 Google API로 사용자 정보 조회
4. 내 DB에 사용자 저장/조회
5. 내 서버에서 JWT 발급
6. 이후 요청은 JWT로 인증
```

```java
@Component
@RequiredArgsConstructor
public class OAuth2SuccessHandler implements AuthenticationSuccessHandler {

    private final JwtTokenProvider tokenProvider;

    @Override
    public void onAuthenticationSuccess(HttpServletRequest request,
                                        HttpServletResponse response,
                                        Authentication authentication) throws IOException {
        CustomOAuth2User oAuth2User = (CustomOAuth2User) authentication.getPrincipal();
        User user = oAuth2User.getUser();

        // JWT 발급
        String accessToken = tokenProvider.createAccessToken(user);
        String refreshToken = tokenProvider.createRefreshToken(user);

        // Refresh Token은 HttpOnly 쿠키로
        ResponseCookie cookie = ResponseCookie.from("refreshToken", refreshToken)
            .httpOnly(true)
            .secure(true)
            .path("/")
            .maxAge(7 * 24 * 60 * 60)
            .build();
        response.addHeader(HttpHeaders.SET_COOKIE, cookie.toString());

        // Access Token은 URL 파라미터로 프론트엔드에 전달
        response.sendRedirect("http://localhost:3000/oauth/callback?token=" + accessToken);
    }
}
```

# 6. 선택 가이드

---

| 상황 | 권장 |
|------|------|
| **전통적 웹앱 (SSR)** | 세션 기반 |
| **SPA + API 서버** | JWT (Access + Refresh) |
| **모바일 앱** | JWT |
| **마이크로서비스** | JWT |
| **제3자 API 연동** | OAuth 2.0 |
| **소셜 로그인** | OAuth 2.0 + JWT |

## 보안 체크리스트

```text
공통:
□ HTTPS 필수
□ 비밀번호는 bcrypt/argon2로 해싱
□ SQL Injection, XSS 방지

세션:
□ 세션 ID는 HttpOnly, Secure 쿠키
□ 세션 고정 공격 방지 (로그인 시 세션 재생성)
□ 세션 타임아웃 설정

JWT:
□ Access Token 짧은 만료 (15분~1시간)
□ Refresh Token은 HttpOnly 쿠키 또는 서버 저장
□ 토큰 블랙리스트 (로그아웃, 비밀번호 변경 시)
□ 민감 정보는 Payload에 넣지 않음

OAuth:
□ state 파라미터로 CSRF 방지
□ PKCE 사용 (SPA/모바일)
□ scope 최소화
```

# 7. 정리

---

| 방식 | 상태 저장 | 확장성 | 무효화 |
|------|----------|--------|--------|
| **세션** | 서버 | 세션 공유 필요 | 즉시 가능 |
| **JWT** | 클라이언트 | 우수 | 블랙리스트 필요 |
| **OAuth 2.0** | 인증 서버 | 위임 방식 | 토큰 폐기 |

```text
핵심:
  인증 = 누구인가, 인가 = 무엇을 할 수 있는가.
  세션 = Stateful, 즉시 무효화 가능.
  JWT = Stateless, 확장 용이, 즉시 무효화 어려움.
  OAuth = 제3자에게 안전하게 권한 위임.
  Access Token은 짧게, Refresh Token으로 재발급.
```

# Reference

---

- [OAuth 2.0 Specification](https://oauth.net/2/)
- [JWT Introduction](https://jwt.io/introduction)
- [Spring Security OAuth2](https://docs.spring.io/spring-security/reference/servlet/oauth2/index.html)
- [OWASP Authentication Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html)
