---
layout: single
title: "[ClaudeCode] 토큰의 이해와 Claude Code 효율적 사용법 - AI 네이티브 개발자 되기"
categories:
  - ClaudeCode
tags:
  - [ClaudeCode, Token, ContextWindow, AIAgent, CostOptimization]
---

# Introduction

---

AI 도구를 사용하는 개발자라면 "토큰"이라는 단어를 자주 접하게 됩니다. 하지만 토큰이 정확히 무엇이고, 왜 중요하며, 어떻게 효율적으로 관리해야 하는지를 이해하는 개발자는 많지 않습니다.

이 글은 AI 네이티브 개발자가 되기 위한 핵심 개념인 **토큰(Token)**과 **컨텍스트 윈도우(Context Window)**를 정리하고, Claude Code를 사용할 때 토큰을 효율적으로 관리하는 실전 방법을 다룹니다.

# 1. 토큰(Token)이란?

---

## AI가 데이터를 처리하는 최소 단위

토큰은 AI 모델이 텍스트를 처리하는 **최소 단위**입니다. 사람이 문장을 단어 단위로 읽는 것처럼, AI 모델은 텍스트를 토큰 단위로 읽고 생성합니다.

```text
"Hello, World!" → ["Hello", ",", " World", "!"]  → 4 토큰
"안녕하세요"     → ["안녕", "하세요"]               → 2 토큰 (모델에 따라 다름)
```

중요한 점은 **AI 모델마다 텍스트를 토큰으로 나누는 방식(토크나이저)이 다르다**는 것입니다. 같은 문장이라도 모델에 따라 토큰 수가 달라질 수 있습니다. 일반적으로 영어는 1 토큰당 약 4글자, 한국어는 1 토큰당 약 1~2글자 수준입니다.

## 입력 토큰 vs 출력 토큰

AI 모델과의 모든 상호작용은 토큰으로 측정되며, 두 종류로 나뉩니다:

| 구분 | 설명 | 예시 |
|------|------|------|
| **입력 토큰 (Input)** | 사용자가 AI에 보내는 모든 데이터 | 메시지, 첨부 파일, 이전 대화 기록, 시스템 프롬프트 |
| **출력 토큰 (Output)** | AI가 생성하는 모든 데이터 | 응답 텍스트, 생성된 코드, 설명 |

```text
사용자 메시지 (입력 토큰)
  ↓
┌─────────────┐
│  AI 모델     │
└─────────────┘
  ↓
AI 응답 (출력 토큰)
```

입력 토큰과 출력 토큰은 **가격이 다릅니다**. Claude 모델 기준으로 출력 토큰이 입력 토큰보다 **5배** 비쌉니다. 따라서 불필요하게 긴 응답을 유도하지 않는 것이 비용 절감에 중요합니다.

| 모델 | 입력 (MTok) | 출력 (MTok) | 배율 |
|------|:-----------:|:-----------:|:----:|
| Haiku 4.5 | $1 | $5 | 5배 |
| Sonnet 4.5 | $3 | $15 | 5배 |
| Opus 4.6 | $5 | $25 | 5배 |

> MTok = 100만 토큰 (Million Tokens)

# 2. 컨텍스트 윈도우(Context Window)

---

## AI가 한 번에 처리할 수 있는 최대 용량

컨텍스트 윈도우는 AI가 **한 번의 요청에서 처리할 수 있는 최대 토큰 수**를 의미합니다. Claude 모델은 기본적으로 **200,000 토큰(200K)**의 컨텍스트 윈도우를 지원하며, Opus 4.6과 Sonnet 4.5는 베타로 **1,000,000 토큰(1M)**까지 확장 가능합니다.

컨텍스트 윈도우 안에는 입력 토큰과 출력 토큰이 **모두** 포함됩니다:

```text
컨텍스트 윈도우 (200K 토큰)
┌─────────────────────────────────────────────┐
│  시스템 프롬프트 + CLAUDE.md                    │
│  + 이전 대화 기록 (입력 + 출력)                  │
│  + 현재 사용자 메시지                           │
│  + AI 응답 (출력)                              │
└─────────────────────────────────────────────┘
```

## 대화가 길어지면 어떻게 될까?

아래 다이어그램은 대화가 진행될수록 컨텍스트 윈도우가 어떻게 채워지는지 보여줍니다:

![컨텍스트 윈도우 동작 다이어그램](/assets/images/claude-code-token/context-window-diagram.png)

핵심 포인트:

- **점진적 토큰 누적**: 대화가 턴을 진행하면서 각 사용자 메시지와 AI 응답이 컨텍스트 윈도우 내에 누적됩니다. 이전 턴은 완전히 보존됩니다.
- **선형 성장 패턴**: 컨텍스트 사용량은 각 턴마다 선형적으로 증가합니다. 도구 호출(파일 읽기, Bash 실행 등)의 결과도 모두 컨텍스트에 포함됩니다.
- **200K 한계**: 총 사용 가능한 컨텍스트 윈도우(200,000 토큰)에 도달하면 더 이상 이전 대화를 참조할 수 없습니다.

컨텍스트 윈도우가 가득 차면 AI는 더 이상 이전 대화를 참조할 수 없게 됩니다. 이것이 **컨텍스트 관리가 중요한 이유**입니다.

## 컨텍스트 관리 명령어

Claude Code에서는 두 가지 핵심 명령어로 컨텍스트를 관리합니다:

| 명령어 | 용도 | 사용 시점 |
|--------|------|-----------|
| `/clear` | 이전 대화 컨텍스트를 완전히 초기화 | 새로운 작업을 시작할 때 |
| `/compact` | 메시지 컨텍스트를 요약/압축 | 작업을 이어가되 공간이 부족할 때 |

```text
# 새 작업 시작 시 - 이전 대화 완전 초기화
> /clear

# 같은 작업을 이어가되 토큰 절약이 필요할 때
> /compact
```

**`/clear`는 언제 사용해야 할까?**

새로운 주제의 작업을 시작할 때 이전 대화 컨텍스트가 남아 있으면, 불필요한 정보가 컨텍스트 윈도우를 차지하게 됩니다. 이는 비용 증가뿐 아니라 **AI의 응답 품질 저하**로 이어질 수 있습니다. 관련 없는 이전 맥락이 현재 작업에 영향을 줄 수 있기 때문입니다.

**`/compact`는 언제 사용해야 할까?**

같은 작업을 이어가고 싶지만 컨텍스트 용량이 거의 찬 경우, `/compact`를 사용하면 이전 메시지를 요약하여 핵심 정보는 유지하면서 토큰 사용량을 줄일 수 있습니다. `/compact [지시사항]` 형태로 요약 시 중점적으로 유지할 내용을 지정할 수도 있습니다.

# 3. Claude 모델별 토큰 가격

---

Claude Code에서 사용할 수 있는 모델과 각 모델의 특성, 가격을 정리합니다. 가격은 2025년 기준 Anthropic API 공식 가격이며, 변경될 수 있으므로 [공식 가격 페이지](https://docs.anthropic.com/en/docs/about-claude/pricing)에서 최신 정보를 확인하시기 바랍니다.

## 모델 비교표

| 모델 | 특성 | 최적 용도 | 입력 (MTok) | 출력 (MTok) | 컨텍스트 윈도우 |
|------|------|-----------|:---:|:---:|:---:|
| **Haiku 4.5** | 가장 빠르고 가벼움 | 간단한 질문, 빠른 작업, 학습 | $1 | $5 | 200K |
| **Sonnet 4.5** | 속도와 성능의 균형 | 일상적인 코딩, 분석 | $3 | $15 | 200K / 1M(베타) |
| **Opus 4.6** | 최고 성능 | 복잡한 에이전트 작업, 고난도 코딩 | $5 | $25 | 200K / 1M(베타) |

## 모델 선택 가이드

```text
간단한 작업 / 학습 목적
  → Haiku 사용 (빠르고 저렴)
  예: "이 함수가 뭐 하는 건지 설명해줘"
      "이 에러 메시지가 무슨 뜻이야?"

일반적인 코딩 작업
  → Sonnet 사용 (성능과 비용의 균형)
  예: "이 컴포넌트에 페이지네이션 기능 추가해줘"
      "테스트 코드를 작성해줘"

복잡한 아키텍처 / 까다로운 디버깅
  → Opus 사용 (최고 성능)
  예: "이 시스템의 아키텍처를 리팩토링해줘"
      "멀티스레드 환경에서 발생하는 데드락을 분석해줘"
```

> Opus는 가격이 높지만, 복잡한 작업을 한 번에 정확하게 처리하여 **재시도 횟수가 줄어들므로** 결과적으로 토큰 소모가 적을 수 있습니다.

Claude Code에서 모델을 변경하려면:

```bash
# 모델 선택 메뉴 열기
> /model

# 빠른 모드 토글 (같은 모델에서 빠른 출력으로 전환)
> /fast
```

> `/fast`는 모델을 변경하는 것이 아니라, 같은 모델에서 더 빠른 출력 속도로 전환하는 기능입니다.

# 4. Claude Code 사용량 제한

---

Claude Code(Max 구독)는 토큰 사용량에 제한이 있습니다. `/usage` 명령어로 현재 사용량을 확인할 수 있습니다.

```bash
> /usage
```

## 제한 종류

| 제한 | 초기화 주기 | 설명 |
|------|-------------|------|
| **Current Session** | 5시간 | 5시간 단위로 초기화되는 사용량. 이 한도가 차면 사용량 제한에 걸림 |
| **주간 제한** | 1주일 | 전체 모델에 대한 제한 + Sonnet 모델 전용 제한으로 분리 |

5시간 세션 한도가 가득 차면 일시적으로 사용이 제한됩니다. 이때는 새 세션이 시작될 때까지 기다리거나, 사용량이 적은 모델(Haiku)로 전환하여 작업을 이어갈 수 있습니다.

## 사용량 제한에 걸리지 않는 팁

```text
1. /usage를 수시로 확인하여 남은 용량 파악
2. 간단한 작업은 Haiku로 전환하여 Sonnet/Opus 한도 보존
3. /clear와 /compact로 불필요한 컨텍스트 제거 → 요청당 입력 토큰 절약
4. 한 번의 프롬프트에 명확한 지시를 담아 재시도 횟수 최소화
```

# 5. 토큰을 효율적으로 사용하는 법

---

## 5-1. 프롬프트 최적화

**명확하고 구체적인 지시**가 토큰 효율의 핵심입니다. 범위를 제한하면 불필요한 코드 생성을 줄일 수 있습니다.

```text
비효율적인 프롬프트:
  "이 프로젝트를 좋게 만들어줘"
  "에러를 고쳐줘"

효율적인 프롬프트:
  "src/auth.ts의 login 함수에서 JWT 만료 시간을 1시간에서 24시간으로 변경해줘"
  "UserService.getById()에서 null 반환 시 404 에러를 던지도록 수정해줘"
```

명확한 범위 지정은 Claude가 코드베이스 전체를 탐색하는 대신 정확한 위치에서 작업하게 하므로, 입력/출력 토큰을 모두 절약합니다.

## 5-2. Haiku 모델 적극 활용

간단한 작업이나 학습 시에는 Haiku 모델을 사용하면 속도와 토큰 효율을 크게 높일 수 있습니다.

```text
Haiku가 적합한 작업:
  - 코드 설명 요청
  - 간단한 코드 생성
  - 에러 메시지 해석
  - 문법 관련 질문
  - 빠른 리팩토링
```

## 5-3. 컨텍스트 관리

새로운 작업을 시작할 때는 반드시 `/clear`로 이전 대화를 초기화하고, 작업 중 컨텍스트가 커지면 `/compact`로 압축합니다.

```text
작업 A 완료
  ↓
/clear (이전 컨텍스트 초기화)
  ↓
작업 B 시작 (깨끗한 컨텍스트에서 시작)
```

```text
작업 중 컨텍스트가 커질 때:
  ↓
/compact (핵심 정보만 남기고 압축)
  ↓
같은 작업 계속 (줄어든 컨텍스트로 계속)
```

> **주의**: `/compact`는 요약 과정에서 세부 정보가 일부 손실될 수 있습니다. 중요한 코드 변경 이력이나 결정 사항은 CLAUDE.md나 별도 파일에 기록해 두는 것이 안전합니다.

## 5-4. 불필요한 확장 요소 최소화

Claude Code의 확장 기능들은 컨텍스트 윈도우를 추가로 차지합니다. 꼭 필요한 것만 활성화해야 합니다.

| 요소 | 컨텍스트 영향 | 최적화 방법 |
|------|:---:|------|
| **서브에이전트** | 높음 | 필요한 경우에만 사용 |
| **MCP 서버** | 중간~높음 | 사용하지 않는 MCP는 비활성화 |
| **CLAUDE.md** | 중간 | 핵심 정보만 간결하게 작성 (300줄 이하 권장) |

```text
CLAUDE.md 작성 시:
  포함할 것: 빌드 명령어, 핵심 컨벤션, 주의사항
  피할 것:  일반적인 프로그래밍 지식, 긴 설명, 중복 정보
```

CLAUDE.md, MCP 서버 설정, 서브에이전트 등의 정보는 **매 요청마다** 입력 토큰에 포함되므로, 이를 최소화하면 세션 전체에서 누적되는 토큰 절약 효과가 큽니다.

# 6. 정리

---

| 개념 | 핵심 정리 |
|------|-----------|
| **토큰** | AI가 데이터를 처리하는 최소 단위. 모든 상호작용이 토큰으로 측정됨 |
| **입력/출력 토큰** | 입력(사용자 메시지)과 출력(AI 응답)으로 나뉘며, 출력이 5배 비쌈 |
| **컨텍스트 윈도우** | AI가 한 번에 처리 가능한 최대 토큰 수 (Claude: 200K, 베타 1M) |
| **`/clear`** | 새 작업 시 이전 대화 초기화 → 깨끗한 컨텍스트 확보 |
| **`/compact`** | 같은 작업 이어갈 때 컨텍스트 압축 → 공간 확보 |
| **모델 선택** | 간단한 작업은 Haiku, 일반 코딩은 Sonnet, 복잡한 작업은 Opus |
| **프롬프트 최적화** | 범위를 명확히 제한하여 불필요한 토큰 소모 방지 |
| **확장 요소 관리** | 서브에이전트, MCP, CLAUDE.md 최소화로 컨텍스트 절약 |

```text
AI 네이티브 개발자의 핵심:
  토큰과 컨텍스트의 본질을 이해하고,
  컨텍스트 윈도우 안에서 꼭 필요한 컨텍스트만 정확하게 전달하는 것
```

# Reference

---

- [Claude Code 공식 문서](https://docs.anthropic.com/en/docs/claude-code)
- [Anthropic 모델 가격](https://docs.anthropic.com/en/docs/about-claude/pricing)
- [Claude 모델 개요](https://docs.anthropic.com/en/docs/about-claude/models)
- [Claude 컨텍스트 윈도우](https://docs.anthropic.com/en/docs/build-with-claude/context-windows)
