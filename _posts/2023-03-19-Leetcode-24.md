# Problem

---

### 24. Swap Nodes in Pairs

- Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)

   

  **Example 1:**

  ![1](../assets/images/03-19-leetcode-24/1.jpeg)

  ```
  Input: head = [1,2,3,4]
  Output: [2,1,4,3]
  ```

  **Example 2:**

  ```
  Input: head = []
  Output: []
  ```

  **Example 3:**

  ```
  Input: head = [1]
  Output: [1]
  ```

   

  **Constraints:**

  - The number of nodes in the list is in the range `[0, 100]`.
  - `0 <= Node.val <= 100`



# Solution

---

### 리스트를 이용한 풀이

- 입력으로 들어오는 연결 리스트들을 리스트화 한 뒤 functools 혹은 join을 이용하여 숫자로 바꾸는 방식을 사용했다.

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        num1 = []
        num2 = []
        while l1:
            num1.append(l1.val)
            l1 = l1.next
        while l2:
            num2.append(l2.val)
            l2 = l2.next
        
        num1.reverse()
        num2.reverse()
        
        # 1) functools
        result1 = functools.reduce(lambda x,y: x*10+y, num1)
        result2 = functools.reduce(lambda x,y: x*10+y, num2)
        
        # 2) join
        # result1 = int("".join(str(e) for e in num1))
        # result2 = int("".join(str(e) for e in num2))

        res = result1 + result2
        node = head = ListNode(0)
        while True:
            _val = res % 10
            res = res // 10
            node.val = _val
            if not res:
                node.next = None
                break

            node.next = ListNode(0)
            node = node.next

            
        return head
```



### 전가산기를 이용한 풀이

- 위와 같은 방식의 풀이지만 다중 할당을 함수 내부에서 prev 설정을 해주지 않아도 된다는 점이 다르다.

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
      
        def reverse(head, prev=None):
            if not head:
                return prev
            _next, head.next = head.next, prev
            return reverse(_next, head)

        return reverse(head)

```



# Conclusion

---

어렵지 않은 문제지만 재귀 풀이법을 이해하는데 시간이 조금 걸렸다.